<!doctype html><html lang=en class="js csstransforms3d"><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=generator content="Hugo 0.110.0"><meta name=description content="An unofficial Microbit v2 API reference & guide book."><meta name=author content="c272"><link rel=icon href=/images/favicon.png type=image/png><title>Interacting over serial I/O - micro:bit v2 Documentation</title><link href=/css/nucleus.css?1675177038 rel=stylesheet><link href=/css/fontawesome-all.min.css?1675177038 rel=stylesheet><link href=/css/hybrid.css?1675177038 rel=stylesheet><link href=/css/featherlight.min.css?1675177038 rel=stylesheet><link href=/css/perfect-scrollbar.min.css?1675177038 rel=stylesheet><link href=/css/auto-complete.css?1675177038 rel=stylesheet><link href=/css/atom-one-dark-reasonable.css?1675177038 rel=stylesheet><link href=/css/theme.css?1675177038 rel=stylesheet><link href=/css/tabs.css?1675177038 rel=stylesheet><link href=/css/hugo-theme.css?1675177038 rel=stylesheet><script src=/js/jquery-3.3.1.min.js?1675177038></script><style>:root #header+#content>#left>#rlblock_left{display:none!important}:not(pre)>code+span.copy-to-clipboard{display:none}</style></head><body data-url=/guides/serial/><nav id=sidebar><div id=header-wrapper><div id=header><a id=logo href=/><img id=grav-logo src=/images/logo.png style=width:100%;height:100%></a></div><div class=searchbox><label for=search-by><i class="fas fa-search"></i></label>
<input data-search-input id=search-by type=search placeholder=Search...>
<span data-search-clear><i class="fas fa-times"></i></span></div><script type=text/javascript src=/js/lunr.min.js?1675177038></script>
<script type=text/javascript src=/js/auto-complete.js?1675177038></script>
<script type=text/javascript>var baseurl="https://microbit.c272.org/"</script><script type=text/javascript src=/js/search.js?1675177038></script></div><section id=homelinks><ul><li><a class=padding href=/><i class='fas fa-home'></i> Home</a></li></ul></section><div class=highlightable><ul class=topics><li data-nav-id=/setup/ title=Setup class=dd-item><a href=/setup/><b>1. </b>Setup</a><ul><li data-nav-id=/setup/linux-install-guide/ title="Installing on Linux" class=dd-item><a href=/setup/linux-install-guide/>Installing on Linux</a></li><li data-nav-id=/setup/mac-install-guide/ title="Installing on MacOS" class=dd-item><a href=/setup/mac-install-guide/>Installing on MacOS</a></li><li data-nav-id=/setup/windows-install-guide/ title="Installing on Windows" class=dd-item><a href=/setup/windows-install-guide/>Installing on Windows</a></li><li data-nav-id=/setup/using-micro-tools/ title="Configuring & Using micro-tools" class=dd-item><a href=/setup/using-micro-tools/>Configuring & Using micro-tools</a></li><li data-nav-id=/setup/debug-setup-guide/ title="Setting up a Debug Environment" class=dd-item><a href=/setup/debug-setup-guide/>Setting up a Debug Environment</a></li></ul></li><li data-nav-id=/guides/ title=Guides class="dd-item
parent"><a href=/guides/><b>2. </b>Guides</a><ul><li data-nav-id=/guides/hello-world/ title="'Hello World' with micro:bit v2" class=dd-item><a href=/guides/hello-world/>'Hello World' with micro:bit v2</a></li><li data-nav-id=/guides/using-the-filesystem/ title="Using the micro:bit file system" class=dd-item><a href=/guides/using-the-filesystem/>Using the micro:bit file system</a></li><li data-nav-id=/guides/logging/ title="Logging with MicroBitLog" class=dd-item><a href=/guides/logging/>Logging with MicroBitLog</a></li><li data-nav-id=/guides/serial/ title="Interacting over serial I/O" class="dd-item active"><a href=/guides/serial/>Interacting over serial I/O</a></li></ul></li><li data-nav-id=/api-reference/ title="API Reference" class=dd-item><a href=/api-reference/><b>3. </b>API Reference</a><ul><li data-nav-id=/api-reference/core/ title=codal-core class=dd-item><a href=/api-reference/core/>codal-core</a><ul><li data-nav-id=/api-reference/core/accelerometer/ title=Accelerometer class=dd-item><a href=/api-reference/core/accelerometer/>Accelerometer</a></li><li data-nav-id=/api-reference/core/button/ title=Button class=dd-item><a href=/api-reference/core/button/>Button</a></li><li data-nav-id=/api-reference/core/compass/ title=Compass class=dd-item><a href=/api-reference/core/compass/>Compass</a></li><li data-nav-id=/api-reference/core/coordinatespace/ title=CoordinateSpace class=dd-item><a href=/api-reference/core/coordinatespace/>CoordinateSpace</a></li><li data-nav-id=/api-reference/core/keyvaluestorage/ title=KeyValueStorage class=dd-item><a href=/api-reference/core/keyvaluestorage/>KeyValueStorage</a></li><li data-nav-id=/api-reference/core/ledmatrix/ title=LEDMatrix class=dd-item><a href=/api-reference/core/ledmatrix/>LEDMatrix</a></li><li data-nav-id=/api-reference/core/managedbuffer/ title=ManagedBuffer class=dd-item><a href=/api-reference/core/managedbuffer/>ManagedBuffer</a></li><li data-nav-id=/api-reference/core/managedstring/ title=ManagedString class=dd-item><a href=/api-reference/core/managedstring/>ManagedString</a></li><li data-nav-id=/api-reference/core/messagebus/ title=MessageBus class=dd-item><a href=/api-reference/core/messagebus/>MessageBus</a></li><li data-nav-id=/api-reference/core/multibutton/ title=MultiButton class=dd-item><a href=/api-reference/core/multibutton/>MultiButton</a></li><li data-nav-id=/api-reference/core/nvmcontroller/ title=NVMController class=dd-item><a href=/api-reference/core/nvmcontroller/>NVMController</a></li><li data-nav-id=/api-reference/core/pin/ title=Pin class=dd-item><a href=/api-reference/core/pin/>Pin</a></li><li data-nav-id=/api-reference/core/sample3d/ title=Sample3D class=dd-item><a href=/api-reference/core/sample3d/>Sample3D</a></li><li data-nav-id=/api-reference/core/timer/ title=Timer class=dd-item><a href=/api-reference/core/timer/>Timer</a></li><li data-nav-id=/api-reference/core/touchbutton/ title=TouchButton class=dd-item><a href=/api-reference/core/touchbutton/>TouchButton</a></li><li data-nav-id=/api-reference/core/license/ title="License & Attribution" class=dd-item><a href=/api-reference/core/license/>License & Attribution</a></li></ul></li><li data-nav-id=/api-reference/microbit-v2/ title=codal-microbit-v2 class=dd-item><a href=/api-reference/microbit-v2/>codal-microbit-v2</a><ul><li data-nav-id=/api-reference/microbit-v2/microbit/ title=MicroBit class=dd-item><a href=/api-reference/microbit-v2/microbit/>MicroBit</a></li><li data-nav-id=/api-reference/microbit-v2/microbitaudio/ title=MicroBitAudio class=dd-item><a href=/api-reference/microbit-v2/microbitaudio/>MicroBitAudio</a></li><li data-nav-id=/api-reference/microbit-v2/microbitblemanager/ title=MicroBitBLEManager class=dd-item><a href=/api-reference/microbit-v2/microbitblemanager/>MicroBitBLEManager</a></li><li data-nav-id=/api-reference/microbit-v2/microbitcompasscalibrator/ title=MicroBitCompassCalibrator class=dd-item><a href=/api-reference/microbit-v2/microbitcompasscalibrator/>MicroBitCompassCalibrator</a></li><li data-nav-id=/api-reference/microbit-v2/microbitdisplay/ title=MicroBitDisplay class=dd-item><a href=/api-reference/microbit-v2/microbitdisplay/>MicroBitDisplay</a></li><li data-nav-id=/api-reference/microbit-v2/microbiti2c/ title=MicroBitI2C class=dd-item><a href=/api-reference/microbit-v2/microbiti2c/>MicroBitI2C</a></li><li data-nav-id=/api-reference/microbit-v2/microbitio/ title=MicroBitIO class=dd-item><a href=/api-reference/microbit-v2/microbitio/>MicroBitIO</a></li><li data-nav-id=/api-reference/microbit-v2/microbitlog/ title=MicroBitLog class=dd-item><a href=/api-reference/microbit-v2/microbitlog/>MicroBitLog</a></li><li data-nav-id=/api-reference/microbit-v2/microbitpowermanager/ title=MicroBitPowerManager class=dd-item><a href=/api-reference/microbit-v2/microbitpowermanager/>MicroBitPowerManager</a></li><li data-nav-id=/api-reference/microbit-v2/microbitradio/ title=MicroBitRadio class=dd-item><a href=/api-reference/microbit-v2/microbitradio/>MicroBitRadio</a></li><li data-nav-id=/api-reference/microbit-v2/microbitthermometer/ title=MicroBitThermometer class=dd-item><a href=/api-reference/microbit-v2/microbitthermometer/>MicroBitThermometer</a></li><li data-nav-id=/api-reference/microbit-v2/microbitusbflashmanager/ title=MicroBitUSBFlashManager class=dd-item><a href=/api-reference/microbit-v2/microbitusbflashmanager/>MicroBitUSBFlashManager</a></li><li data-nav-id=/api-reference/microbit-v2/license/ title="License & Attribution" class=dd-item><a href=/api-reference/microbit-v2/license/>License & Attribution</a></li></ul></li><li data-nav-id=/api-reference/nrf52/ title=codal-nrf52 class=dd-item><a href=/api-reference/nrf52/>codal-nrf52</a><ul><li data-nav-id=/api-reference/nrf52/nrf52adc/ title=NRF52ADC class=dd-item><a href=/api-reference/nrf52/nrf52adc/>NRF52ADC</a></li><li data-nav-id=/api-reference/nrf52/nrf52flashmanager/ title=NRF52FlashManager class=dd-item><a href=/api-reference/nrf52/nrf52flashmanager/>NRF52FlashManager</a></li><li data-nav-id=/api-reference/nrf52/nrf52pin/ title=NRF52Pin class=dd-item><a href=/api-reference/nrf52/nrf52pin/>NRF52Pin</a></li><li data-nav-id=/api-reference/nrf52/nrf52serial/ title=NRF52Serial class=dd-item><a href=/api-reference/nrf52/nrf52serial/>NRF52Serial</a></li><li data-nav-id=/api-reference/nrf52/nrf52touchsensor/ title=NRF52TouchSensor class=dd-item><a href=/api-reference/nrf52/nrf52touchsensor/>NRF52TouchSensor</a></li><li data-nav-id=/api-reference/nrf52/nrflowleveltimer/ title=NRFLowLevelTimer class=dd-item><a href=/api-reference/nrf52/nrflowleveltimer/>NRFLowLevelTimer</a></li><li data-nav-id=/api-reference/nrf52/license/ title="License & Attribution" class=dd-item><a href=/api-reference/nrf52/license/>License & Attribution</a></li></ul></li></ul></li></ul><section id=footer><p>Built with <a href=https://github.com/matcornic/hugo-theme-learn><i class="fas fa-heart"></i></a> by <a href=https://github.com/c272>C272</a>.<br></p><p style=color:#64586e;margin-top:.5em>This site is not affiliated, associated, authorized, or endorsed by the BBC or Lancaster University.</p></section></div></nav><section id=body><div id=overlay></div><div class="padding highlightable"><div><div id=top-bar><div id=breadcrumbs itemscope itemtype=http://data-vocabulary.org/Breadcrumb><span id=sidebar-toggle-span><a href=# id=sidebar-toggle data-sidebar-toggle><i class="fas fa-bars"></i></a></span>
<span id=toc-menu><i class="fas fa-list-alt"></i></span>
<span class=links><a href=/>Home</a> > <a href=/guides/>Guides</a> > Interacting over serial I/O</span></div><div class=progress><div class=wrapper><nav id=TableOfContents><ul><li><a href=#setting-up-microbitserial>Setting Up MicroBitSerial</a></li><li><a href=#sending--receiving-over-serial>Sending & Receiving Over Serial</a></li><li><a href=#codalserial-printf>CODAL::Serial &ldquo;printf&rdquo;</a></li><li><a href=#managing-buffer-space>Managing Buffer Space</a></li></ul></nav></div></div></div></div><div id=head-tags></div><div id=body-inner><h1>Interacting over serial I/O</h1><p>The micro:bit API allows you to transfer information out from the board to external machines (and other micro:bits!) in various ways. One of these is through the use of serial transmission, which has been a feature of the API since micro:bit v1, with only a few very minor breaking name changes carrying over into the v2 API. This guide will discuss how to set up a serial connection over the USB UART port on the micro:bit, and communicate with an external machine (for the purposes of this exercise, this will be a Linux computer).</p><h2 id=setting-up-microbitserial>Setting Up MicroBitSerial</h2><p>Initialising serial is incredibly simple, and only requires that we initialise a <code>MicroBitSerial</code> instance with the requested output (transmit) pin <code>TX</code>, and the input (receive) pin <code>RX</code>. Available pins for serial on the micro:bit v2 are the edge pins <code>MICROBIT_PIN_P0</code> through <code>MICROBIT_PIN_P20</code>, as well as the USB UART at <code>USB_UART_RX</code> and <code>USB_UART_TX</code>. The default baud rate is <strong>115200</strong>, however this can be configured through CODAL&rsquo;s <code>Serial</code> class. We can also configure how large or small we want the transmit and receive buffers to be as the third and fourth argument, with the default being 20 bytes.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>MicroBit uBit;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>//If you want to use the serial from the micro:bit parent object, simply:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    uBit.init();
</span></span><span style=display:flex><span>    uBit.serial.setBaud(...);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//If you want to set up a connection manually without using MicroBit:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    MicroBitSerial serial(USB_UART_TX, USB_UART_RX, <span style=color:#ae81ff>64</span>, <span style=color:#ae81ff>64</span>);
</span></span><span style=display:flex><span>    serial.setBaud(<span style=color:#ae81ff>57600</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>You can only set the baud rate to a limited set of supported values, and the driver will currently simply ignore your request and reset the rate to the default if you pass an unsupported value. CODAL&rsquo;s <code>Serial.hpp</code> states that:</p><blockquote><p>* @note The underlying implementation chooses the first allowable rate at or above that requested.</p></blockquote><p>However, this is a slightly misleading comment. The <code>NR52Serial</code> driver will simply default to resetting the baud rate to 115200 if you pass a value that is unsupported. Available baud values are (default bolded): 9600, 31250, 38400, 57600, <strong>115200</strong>, 230400, 921600 and 1000000.</p><h2 id=sending--receiving-over-serial>Sending & Receiving Over Serial</h2><p>Now that we have initialised our instance of <code>MicroBitSerial</code>, we can begin sending and receiving data between the micro:bit and our host machine. For the sake of this guide, we will assume that upon receiving a null-terminated string, the host machine will respond with that string, reversed. So, if the micro:bit sends <code>HELLO!</code> over serial, it will then receive back <code>!OLLEH</code>. In reality, you will have to write a program to handle the receiving of serial input on the PC side as well, however that is not within the scope of this guide. You can take a look at <a href=https://blog.mbedded.ninja/programming/operating-systems/linux/linux-serial-ports-using-c-cpp/#basic-setup-in-c>this article</a> by <em>mbedded.ninja</em> which explains in detail how you would set up serial handling in C on Linux.</p><p>First of all, let&rsquo;s create the string we&rsquo;re going to send over to the PC side as a C++ string. We can then send it over the wire with the <code>Serial.send()</code> method. There are several blocking types that you can select when sending and receiving serial in CODAL by providing a second parameter, which are:</p><ul><li><code>ASYNC</code>: The call to <code>send()</code> doesn&rsquo;t block at all, simply copying the bytes to send into the transmit buffer and returning. <strong>Payloads will be clipped</strong> upon reaching the limit of the transmit buffer.</li><li><code>SYNC_SPINWAIT</code>: Bytes are copied into the transmit buffer, and then the process spinlocks until transmitted. Blocks all fibers.</li><li><code>SYNC_SLEEP</code> (default): Bytes are copied into the transmit buffer, and then the current fiber is suspended until transmission is complete.</li></ul><p>For the purposes of this example, we&rsquo;re perfectly fine with using <code>SYNC_SLEEP</code>, however in other use cases (such as when using message bus events to wait for serial) not blocking to wait for transit may be a desirable trait.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>//String to send.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>std<span style=color:#f92672>::</span>string toSend <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;HELLO!&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//Send serial and make this fiber wait until everything is flushed out.
</span></span></span><span style=display:flex><span><span style=color:#75715e>//We also send a null terminator so the PC knows the string is over.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>serial.send(toSend.c_str());
</span></span><span style=display:flex><span>serial.sendChar(<span style=color:#e6db74>&#39;\0&#39;</span>);
</span></span></code></pre></div><p>Now that we&rsquo;ve sent our string out over serial, we should wait for a response from the PC. We know the length of the response we&rsquo;re looking for: it&rsquo;s going to be the same as the length of the string we just sent out, since we&rsquo;re just reversing it. We can use the <code>read()</code> function to grab the desired number of characters from our stream.<div class="notices info"><p>Be careful when using <code>read()</code> along with the <code>ASYNC</code> serial mode! When CODAL is using <code>SYNC_SPINWAIT</code> or <code>SYNC_SLEEP</code>, calling <code>read()</code> will simply block until enough characters/data have been read into the receive buffer to satisfy the request. However, when using <code>ASYNC</code> mode, the call will simply return whatever data was immediately available at the time, and is not guaranteed to be of the right length.</p></div></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>//Get our response back out.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>std<span style=color:#f92672>::</span>string response <span style=color:#f92672>=</span> serial.read(toSend.size()).toCharArray();
</span></span></code></pre></div><p>Now that we&rsquo;ve received our response, we&rsquo;re done; here we will simply print it out to the micro:bit&rsquo;s display.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>while</span> (true)
</span></span><span style=display:flex><span>    uBit.display.scroll(response);
</span></span></code></pre></div><h2 id=codalserial-printf>CODAL::Serial &ldquo;printf&rdquo;</h2><p>CODAL in some configurations (<code>CODAL_PROVIDE_PRINTF</code> enabled in config file) also supports the use of a stripped-down &ldquo;<code>printf</code>&rdquo; function over serial. This acts identically to a standard libc <code>printf</code>, however with a very limited set of available format codes. The available format codes to <code>Serial::printf</code> are:</p><ul><li>Character (<code>%c</code>)</li><li>Signed Integer (<code>%d</code>)</li><li>String (<code>%s</code>)</li><li>Percentage Escape Code (<code>%%</code>)</li><li>Hexadecimal (<code>%x</code>/<code>%X</code>)</li></ul><p>This function is blocking and cannot be supplied a serial mode, unlike all <code>read()</code> and <code>send()</code> methods. An example usage would be something like:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> stringArg <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;test&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> percentage <span style=color:#f92672>=</span> <span style=color:#ae81ff>100</span>;
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>serial.printf(<span style=color:#e6db74>&#34;This is a %s of formatting codes. %d%% serial!&#34;</span>, stringArg, percentage);
</span></span></code></pre></div><p>Considering the limitations applied, if you are using CODAL with a modern C++ runtime, then it is likely much more efficient to simply use the string manipulation features offered by <code>std::string</code> and other C++ standard library classes instead of using this method.</p><h2 id=managing-buffer-space>Managing Buffer Space</h2><p>If you are utilising the <code>ASYNC</code> serial mode, you will need to monitor the available receive (RX) and transmit (TX) buffer space to ensure that you are not dropping any bytes on receive and send. To enable this, <code>Serial</code> exposes the <code>getTxBufferSize()</code> and <code>getRxBufferSize()</code> functions to get the total buffer sizes, and the <code>txBufferedSize()</code> and <code>rxBufferedSize()</code> functions to read the current number of bytes stored in each buffer.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>if</span> (serial.getTxBufferSize() <span style=color:#f92672>-</span> serial.txBufferedSize() <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>10</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>//We have 10 bytes spare in the TX buffer, do something.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (serial.rxBufferedSize() <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>10</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>//We have 10 bytes waiting to be read in the RX buffer, do something.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>You can also resize each of these buffers at runtime, so you could, for instance, increase or decrease your buffer space based on load.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>//Increase TX and RX buffer sizes.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>serial.setRxBufferSize(<span style=color:#ae81ff>128</span>);
</span></span><span style=display:flex><span>serial.setTxBufferSize(<span style=color:#ae81ff>128</span>);
</span></span></code></pre></div><footer class=footline></footer></div></div><div id=navigation></div></section><div style=left:-1000px;overflow:scroll;position:absolute;top:-1000px;border:none;box-sizing:content-box;height:200px;margin:0;padding:0;width:200px><div style=border:none;box-sizing:content-box;height:200px;margin:0;padding:0;width:200px></div></div><script src=/js/clipboard.min.js?1675177038></script>
<script src=/js/perfect-scrollbar.min.js?1675177038></script>
<script src=/js/perfect-scrollbar.jquery.min.js?1675177038></script>
<script src=/js/jquery.sticky.js?1675177038></script>
<script src=/js/featherlight.min.js?1675177038></script>
<script src=/js/highlight.pack.js?1675177038></script>
<script>hljs.initHighlightingOnLoad()</script><script src=/js/modernizr.custom-3.6.0.js?1675177038></script>
<script src=/js/learn.js?1675177038></script>
<script src=/js/hugo-learn.js?1675177038></script>
<script src=/mermaid/mermaid.js?1675177038></script>
<script>mermaid.initialize({startOnLoad:!0})</script></body></html>